<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fire Studio</title>
  
  <subtitle>记录，学习，成长</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://firestudio.cn/"/>
  <updated>2019-07-20T08:29:55.944Z</updated>
  <id>http://firestudio.cn/</id>
  
  <author>
    <name>Yozone W.</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于 iOS 应用主题管理与动态切换的一些想法与实现</title>
    <link href="http://firestudio.cn/2019/07/20/how-to-manage-ios-themes-and-switch-themes-dynamically/"/>
    <id>http://firestudio.cn/2019/07/20/how-to-manage-ios-themes-and-switch-themes-dynamically/</id>
    <published>2019-07-19T17:08:41.000Z</published>
    <updated>2019-07-20T08:29:55.944Z</updated>
    
    <content type="html"><![CDATA[<p>今天突然想写篇博客，看了上一篇的发表时间，已经快接近三年半了，着实惭愧啊~。这篇文章主要介绍一下前段时间突发奇想写的一个管理 iOS 主题的开源小库：<a href="https://github.com/azone/ThemeManager" target="_blank" rel="noopener">ThemeManager</a>。</p><h3 id="为何要实现一个管理主题的库"><a class="markdownIt-Anchor" href="#为何要实现一个管理主题的库"></a> 为何要实现一个管理主题的库</h3><p>其实做一个方便管理和切换 iOS 主题的库的想法是好几年前的事了，在这期间脑补过很多实现方案，当想开始做的时候又由于想到了方案的不足再加上我对切换主题没有什么需求，导致一直搁浅。前段时间突发奇想，来了灵感，先在脑袋里打了个草稿，几周后着手开始做，加上一两天空闲时间做的实验，最终花了我一晚上的时间（下班后，包括代码 + Demo + README + 适配各种依赖管理工具(Swift Package, Carthage, CocoaPods，包括本地测试) + 传到 <a href="https://cocoapods.org/pods/WYZThemeManager" target="_blank" rel="noopener">CocoaPods</a> 上，最终两点多完成）终于把这个库做出来了。所以做这玩意纯粹是个人兴趣加上突发奇想。</p><a id="more"></a><h3 id="主题管理库的实现方案"><a class="markdownIt-Anchor" href="#主题管理库的实现方案"></a> 主题管理库的实现方案</h3><h4 id="一般的思路"><a class="markdownIt-Anchor" href="#一般的思路"></a> 一般的思路</h4><p>依照常规的想法以及大部分现有开源库的思路，基本上都是先实现一个自定义的主题类，比如：<code>MyTheme</code>，在其中实现 UI 配置相关的属性，比如背景色、前景色、字体、背景图片等。然后实现一套自己的配置 UI 方面的方法，比如：<code>my_backgroundColor</code>，然后有一个叫 <code>ThemeManager</code> 的东西通过相应的方法负责切换主题，切换主题一般是 <code>ThemeManager</code> 发个通知，然后 UI 控件监听了此通知，然后做出相应的修改。我在 GitHub 上看到一个别人写的基于 Swift 的管理主题的库，也不知为何这么多 star，大致看了一下代码，虽然实现了切换主题的功能，但是设置 UI 属性时是将所有主题的相应属性值赋给 UI 属性，比如 <code>label.theme_textColor = [&quot;#000&quot;, &quot;#FFF&quot;]</code>，切换主题时通过 <code>ThemeManager.setTheme(index: isNight ? 1 : 0)</code> 这种方式，这种实现方式怎么说呢。。。我觉得只能用“呵呵”来代表我的想法吧。</p><h4 id="类似这种思路的缺点"><a class="markdownIt-Anchor" href="#类似这种思路的缺点"></a> 类似这种思路的缺点</h4><p>优点我就不说了，可能也就是能切换主题。但是缺点却是一大堆的，我可以罗列一些：</p><ul><li>实现臃肿、繁琐，需要对每个 UI 控件实现自己的 UI 配置方法，具体实现可能让人觉得会诡异；</li><li>对系统控件有侵入性，有些方法或属性等需要通过 <code>Method Swizzling</code> 特性来实现，可能会带来一些未知的问题；</li><li>扩展性极差，你只能使用开源库所实现的一些方法，如果有一些需要跟随主题动态改变的东西，你就无法实现了。</li><li>可能需要注册过多的通知，由于可能是通过通知进行更换主题的，所以每个 UI 控件的实例或者相应的辅助类都需要监听主题改变的通知，我相信大家也都知道通知过多带来的坏处；</li><li>占用更多的内存，首先是因为注册了过多的通知，其次是可能保存了各种主题配置，再次可能是由于实现主题切换功能，可能会需要很多的辅助类等。</li><li>如果 UIKit 有更新，还需要实现相应的方法，可能导致库的更新不及时，也就导致你无法及时使用新的 UI 特性。</li><li>……</li></ul><h4 id="我的思路"><a class="markdownIt-Anchor" href="#我的思路"></a> 我的思路</h4><p>我最初的思路是有个 <code>ThemeManager</code> 用来管理和切换主题（这个肯定都一样），然后初始注册一个主题到 <code>ThemeManager</code>，但最主要的是怎么实现主题的切换。最一开始我想到的是扩展 UI 控件的方法，比如 <code>-[UIView theme_setBackgroundColor:]</code>， 内部通过 <code>-[ThemeManger setViewObject:forUIKeyPath:toValueOfThemeKeyPath:]</code> 的方法将这些数据记录到 <code>NSMapTable</code> 数据类型的属性中，切换主题时只需要遍历这个属性，执行相应的方法即可实现主题的切换。</p><p>初看上去很不错哦，特别是 Swift 4 之后加入了 <code>KeyPath</code> 特性，都是后面一想还是不行的。因为有些是通过方法来设置 UI 属性的，比如说：<code>-[UIButton setTitleColor:forState:]</code>，这种通过这样的方法就不好实现（当然也能实现，只是感觉比较丑陋、不够优雅，不是我想要的结果）。</p><p>就算以上的想法都实现了，但是还有一个问题我无法接受，就是内存占用问题。虽然用了 <code>NSMapTable</code>，但是 <code>UIView</code> 释放掉之后只是其 Key 自动变成了 <code>nil</code>，但是保存的 Value 仍然在内存中没有释放。何时以及怎么释放这些 Value 是个问题。</p><p>就是因为这些问题，困扰了我好几年的时间。前段时间突然开窍了，想到一个绝妙的方法来实现 UI 属性设置的问题，那就是通过闭包将设置属性的设置放进去，然后通过 <code>ThemeItem</code> 的结构体将 UI 和设置属性的闭包进行关联和存储。</p><p>这个是实现了，但是怎么做到 UI 释放掉之后自动清空其闭包呢？这个也是费了我几天的时间来思考，开始的想法是通过 <code>Method Swizzling</code> 来交换 <code>dealloc</code> 方法，然后在交换方法中移除相应的 <code>ThemeItem</code>。但是代码写完了之后发现编译器报错了，是不允许交换 <code>dealloc</code> 方法的，网上搜了一下发现可以通过 <code>NSSelectorFromString</code> 的函数进行交换，试了一下结果并没有任何卵用，交换是失败的，没有走。。。最后突然来了灵光闪现，我可以通过 <code>objc runtime</code> 的关联对象特性来解决这个问题呀！</p><p>我创建了一个 <code>DeallocObserver</code> 的类，里面放了两个属性，一个是记录需要观察被释放的对象的内存地址，这样我不需要对被观察对象进行引用，不会影响被观察者的生命周期；另一个是被观察对象被释放后需要执行的闭包，闭包有个参数值，就是存储的已释放对象之前的内存地址。我将 <code>DeallocObserver</code> 关联到被观察对象上，当被观察对象释放的时候，由于已经没人在引用 <code>DeallocObserver</code> 了，所以 <code>DeallocObserver</code> 也会紧接着被释放，此时就会执行到 <code>DeallocObserver</code> 的闭包，告诉外面做一些清理工作。比如我用来存储 <code>ThemeItem</code> 的变量 <code>private var managedItems = [Int: [ThemeItem]]()</code>，因为 <code>managedItems</code> 是个字典，Key 值为被观察对象的内存地址，所以只需要执行 <code>managedItems.removeValue(forKey:#memory address#)</code> 即可。</p><p>Perfect! 所有的问题都解决了，实现方式超乎寻常的简单，最终代码只有不到 90 行，具体实现可以看一下 <a href="https://github.com/azone/ThemeManager/blob/0.1.0/Sources/ThemeManager/ThemeManager.swift" target="_blank" rel="noopener">ThemeManager.swift</a>。</p><h4 id="后续的改进02"><a class="markdownIt-Anchor" href="#后续的改进02"></a> 后续的改进(0.2)</h4><p>由于第一版仅支持基于 UIView 的对象，发出去之后没几天想到一个想到一个了一个问题，有一些非继承自  UIView 的类就无法实现主题的切换了，比如一些继承自 <code>UIBarItem</code> 的类。那何必将其限定死为 <code>UIView</code> 呢？于是我将 <code>ThemeItem</code> 的类型限定开放为 AnyObject 了。</p><p>这样做有什么好处？好处显而易见，我不经过可以动态设置 <code>UIView</code> 的属性，我还可以动态设置其它类型的属性，比如：<code>UIBarButtonItem</code> 的 <code>title</code>、<code>image</code> 等。另外我还改造了 <code>ThemeManager</code> 的 <code>setup</code> 方法，参数变为 Optional 参数，如果为 <code>nil</code> 就什么都不做，极大的方便了编码效率，举个例子，比如需要设置 <code>navigationController?.navigationBar</code> 的属性，我只需要通过如下代码即可轻松实现：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">themeManager.setup(navigationController?.navigationBar) &#123; (bar, theme) <span class="keyword">in</span></span><br><span class="line">    bar.tintColor = theme.mainColor</span><br><span class="line">    bar.barTintColor = theme.backgroundColor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了 UI 的样式之外，后来我也想到，我的 <code>ThemeManager</code> 不仅仅可以做主题的切换，还可以做多语言的切换等所有你能想得到的它可以实现的东西，而所有这些没有动到 <code>UIKit</code> 的任何一点东西，比如想做一个多语言的切换，可以简单的实现如下方法：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要实现 Theme 协议</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Language</span>: <span class="title">Theme</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> greeting: <span class="type">String</span> = <span class="string">"Hello"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化 ThemeManager 并使用默认的语言</span></span><br><span class="line"><span class="keyword">let</span> languageManager = <span class="type">ThemeManager</span>(<span class="type">Language</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 label 的标题</span></span><br><span class="line">languageManager.setup(label) &#123; (label, language) <span class="keyword">in</span></span><br><span class="line">    lable.text = language.gretting</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 切换语言，不管你用任何方式加载语言文件或初始化 Language，比如</span></span><br><span class="line"><span class="keyword">var</span> zhLanguage = <span class="type">Language</span>();</span><br><span class="line">zhLanguage.greeting = <span class="string">"你好"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 变更语言</span></span><br><span class="line">languageManager.apply(zhLanguage)</span><br></pre></td></tr></table></figure><h4 id="将来可以新增的特性"><a class="markdownIt-Anchor" href="#将来可以新增的特性"></a> 将来可以新增的特性</h4><p>这些功能虽然足够用了，但是我觉得还可以做得更多。iOS 13 马上就要发布了，大家都知道 iOS 13 加入了黑色主题的支持，下一步我想做的就是监听系统黑白主题的的变化，通过回调告诉外面，然后你自己做决定是否根据系统主题的切换而切换当前主题。虽然系统提供了自动切换题的方法，但是系统将你的主题限定死了，只能使用两种主题，想要实现更多的主题，通过我这个库来实现，没错的~。除了这个之外，我还想在下一版支持自定义动画切换功能。</p><h3 id="优点总结"><a class="markdownIt-Anchor" href="#优点总结"></a> 优点总结</h3><ul><li>说到优点，首先一点就是对系统没有任何的入侵性，没有对系统库做任何修改；</li><li>比较好的内存管理，相应的对象被释放后，其对应的相应的配置也被释放，而且当前仅保存一个主题实例；</li><li>自由度很大，我不管你的 <code>Theme</code> 如何实现，不管你是怎么加载和保存主题的，你要做的只是实现我的 <code>Theme</code> 这个空的协议；</li><li>系统发布新版本、新特性时，你不需要管 <code>ThemeManager</code>，它一样可以运行，并实现你想要的所有新特性；</li><li>〇 通知注册，没有注册任何的通知；</li><li>体积小、使用简单，这个库总共代码行数才 89 行（0.2 版本，包括空行和注释），虽然代码少、实现简单，但是可以满足几乎所有主题和语言切换的所有功能；</li><li>支持主题切换动画，是主题切换起来过渡自然（过渡动画仅对可见视图有效，不可见视图使用动画是无任何意义的）。</li></ul><p>最后，如果你觉得这个库还可以的话，那么欢迎您使用并 star，欢迎提出宝贵意见或者 PR。GitHub 地址：<a href="https://github.com/azone/ThemeManager" target="_blank" rel="noopener">https://github.com/azone/ThemeManager</a></p><p><em>刚才发现搜狐的畅言竟然给我加了一些恶心的广告，果断弃用，还是改用 <a href="https://disqus.com" target="_blank" rel="noopener">disqus</a> 吧</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天突然想写篇博客，看了上一篇的发表时间，已经快接近三年半了，着实惭愧啊~。这篇文章主要介绍一下前段时间突发奇想写的一个管理 iOS 主题的开源小库：&lt;a href=&quot;https://github.com/azone/ThemeManager&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ThemeManager&lt;/a&gt;。&lt;/p&gt;
&lt;h3 id=&quot;为何要实现一个管理主题的库&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#为何要实现一个管理主题的库&quot;&gt;&lt;/a&gt; 为何要实现一个管理主题的库&lt;/h3&gt;
&lt;p&gt;其实做一个方便管理和切换 iOS 主题的库的想法是好几年前的事了，在这期间脑补过很多实现方案，当想开始做的时候又由于想到了方案的不足再加上我对切换主题没有什么需求，导致一直搁浅。前段时间突发奇想，来了灵感，先在脑袋里打了个草稿，几周后着手开始做，加上一两天空闲时间做的实验，最终花了我一晚上的时间（下班后，包括代码 + Demo + README + 适配各种依赖管理工具(Swift Package, Carthage, CocoaPods，包括本地测试) + 传到 &lt;a href=&quot;https://cocoapods.org/pods/WYZThemeManager&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;CocoaPods&lt;/a&gt; 上，最终两点多完成）终于把这个库做出来了。所以做这玩意纯粹是个人兴趣加上突发奇想。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://firestudio.cn/categories/ios/"/>
    
      <category term="UIKit" scheme="http://firestudio.cn/categories/ios/uikit/"/>
    
      <category term="Swift" scheme="http://firestudio.cn/categories/ios/uikit/swift/"/>
    
    
      <category term="iOS" scheme="http://firestudio.cn/tags/ios/"/>
    
      <category term="UIKit" scheme="http://firestudio.cn/tags/uikit/"/>
    
      <category term="Swift" scheme="http://firestudio.cn/tags/swift/"/>
    
  </entry>
  
  <entry>
    <title>Swift 下 OpenGL 截图容易导致的内存泄露</title>
    <link href="http://firestudio.cn/2016/03/11/take-screenshot-of-eaglview-may-easily-cause-memory-leaks-in-swift/"/>
    <id>http://firestudio.cn/2016/03/11/take-screenshot-of-eaglview-may-easily-cause-memory-leaks-in-swift/</id>
    <published>2016-03-11T02:38:57.000Z</published>
    <updated>2019-03-27T14:23:09.918Z</updated>
    
    <content type="html"><![CDATA[<p>由于业务需求，需要对两个（现在是三个了）中的一个 OpenGL 渲染的视图进行截图并增加模糊效果。开始用传统的方法进行截图，但是失败了（截取的是黑屏还是空白，忘记了。。。），后来意识到这个和一般的视图应该是不一样的，就到  Google 上搜了一下。由于没怎么玩过，又不怎么懂，就直接翻译成 <code>Swift</code> 了。开始是没发现什么问题的，都是但是到后来发现截图总是其中一个的（看那个先出来，基本上不是想要的那个），而不是想要的那个。</p><p>仔细研究后发现，OpenGL 的截图是根据 RenderBuffer 来截取的，由于没有指定 RenderBuffer 所以截取的图只是其中某一个。知道了这个也没用，由于这个 View 用的是第三方库，所以不知道这个 View 的 RenderBuffer。。。后果经过 Debug，发现这个 View 有个 <code>_colorRenderBuffer</code> 属性，这就好办啦~。经过改造后代码如下：</p><a id="more"></a><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">snapshotForEAGLView</span><span class="params">(glView: UIView)</span></span> -&gt; <span class="type">UIImage</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> width: <span class="type">GLint</span> = <span class="number">0</span>, height: <span class="type">GLint</span> = <span class="number">0</span></span><br><span class="line">   <span class="keyword">let</span> scale: <span class="type">CGFloat</span> = <span class="type">UIScreen</span>.mainScreen().scale</span><br><span class="line">   <span class="keyword">let</span> prevGLContext = <span class="type">EAGLContext</span>.currentContext()</span><br><span class="line">   <span class="comment">// glView 有个 _colorRenderBuffer 属性(由于 glView 是第三方库的视图，所以只能通过这种方法来获取 _colorRenderBuffer)，需要将它与 GL_RENDERBUFFER 绑定，否则出现的截图可能是另外一个 OpenGL 视图</span></span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">let</span> colorRenderBuffer = glView.valueForKeyPath(<span class="string">"_colorRenderBuffer"</span>) <span class="keyword">as</span>? <span class="type">Int</span> &#123;</span><br><span class="line">       glBindRenderbuffer(<span class="type">GLenum</span>(<span class="type">GL_RENDERBUFFER</span>), <span class="type">GLuint</span>(colorRenderBuffer))</span><br><span class="line"></span><br><span class="line">       glGetRenderbufferParameteriv(<span class="type">GLenum</span>(<span class="type">GL_RENDERBUFFER</span>), <span class="type">GLenum</span>(<span class="type">GL_RENDERBUFFER_WIDTH</span>), &amp;width)</span><br><span class="line">       glGetRenderbufferParameteriv(<span class="type">GLenum</span>(<span class="type">GL_RENDERBUFFER</span>), <span class="type">GLenum</span>(<span class="type">GL_RENDERBUFFER_HEIGHT</span>), &amp;height)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// glView 有个 _context 属性，需要将它设置成当前的 EAGLContext，并且执行 presentRenderbuffer 方法用来把 CAEAGLLayer 渲染出来</span></span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">let</span> glContext = glView.valueForKeyPath(<span class="string">"_context"</span>) <span class="keyword">as</span>? <span class="type">EAGLContext</span> &#123;</span><br><span class="line">           <span class="type">EAGLContext</span>.setCurrentContext(glContext)</span><br><span class="line">           glContext.presentRenderbuffer(<span class="type">Int</span>(<span class="type">GL_RENDERBUFFER</span>)) <span class="comment">// 显示当前 view 的 CAEAGLLayer</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       width = <span class="type">GLint</span>(glView.bounds.width * scale)</span><br><span class="line">       height = <span class="type">GLint</span>(glView.bounds.height * scale)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> dataLength = width * height * <span class="number">4</span></span><br><span class="line">   <span class="keyword">let</span> imageBytes = <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">GLubyte</span>&gt;.alloc(<span class="type">Int</span>(dataLength))</span><br><span class="line">   <span class="comment">// 将图像信息存入内存</span></span><br><span class="line">   glPixelStorei(<span class="type">GLenum</span>(<span class="type">GL_PACK_ALIGNMENT</span>), <span class="number">4</span>)</span><br><span class="line">   <span class="comment">// 读取图像的像素信息并写入到 imageBytes</span></span><br><span class="line">   glReadPixels(<span class="number">0</span>, <span class="number">0</span>, <span class="type">GLsizei</span>(width), <span class="type">GLsizei</span>(height), <span class="type">GLenum</span>(<span class="type">GL_RGBA</span>), <span class="type">GLenum</span>(<span class="type">GL_UNSIGNED_BYTE</span>), imageBytes)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> dataProvider = <span class="type">CGDataProviderCreateWithData</span>(<span class="literal">nil</span>, imageBytes, <span class="type">Int</span>(dataLength), <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">   <span class="type">EAGLContext</span>.setCurrentContext(prevGLContext)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> colorSpace = <span class="type">CGColorSpaceCreateDeviceRGB</span>()</span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">let</span> imageRef = <span class="type">CGImageCreate</span>(<span class="type">Int</span>(width), <span class="type">Int</span>(height), <span class="number">8</span>, <span class="number">32</span>, <span class="type">Int</span>(width) * <span class="number">4</span>, colorSpace, [<span class="type">CGBitmapInfo</span>.<span class="type">ByteOrder32Big</span>, <span class="type">CGBitmapInfo</span>(rawValue: <span class="type">CGImageAlphaInfo</span>.<span class="type">PremultipliedLast</span>.rawValue)], dataProvider, <span class="literal">nil</span>, <span class="literal">true</span>, <span class="type">CGColorRenderingIntent</span>.<span class="type">RenderingIntentDefault</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="type">UIImage</span>(<span class="type">CGImage</span>: imageRef, scale: scale, orientation: .<span class="type">DownMirrored</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="type">UIImage</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很棒！但是很快又发现了问题，挂时间稍长就会崩溃（这个在之前也是有的，只是精力全放在另外一个问题上了）！经过调试后发现有很严重的内存泄露问题！！！从代码可以很容易看出是由于 <code>imageBytes</code> 没有释放的原因，于是在 <code>let dataProvider = CGDataProviderCreateWithData(nil, imageBytes, Int(dataLength), nil)</code> 下面加了两行代码来释放内存：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">imageBytes.destroy()</span><br><span class="line">imageBytes.dealloc(<span class="type">Int</span>(dataLength))</span><br></pre></td></tr></table></figure><p>这样做虽然内存释放掉了，但是又出问题了。。。截的图不见了，调试发现图是空的。经过分析得知由于 <code>UIImage</code>、<code>dataProvider</code> 和 <code>imageRef</code> 用的是一块内存，所以上面两行代码等于把 UIImage 的内存也释放掉了。</p><p>现在要做的就是把 <code>imageBytes</code> 拷一份出来，这样再释放 <code>imageBytes</code> 就不会有影响了。通过查文档得知 <code>CGDataProviderRef</code> 可以通过 <code>CGDataProviderCreateWithCFData</code> 来创建，<code>CFDataRef</code> 又可以通过 <code>CFDataCreate</code> 来创建，通过 <code>CFDataCreate</code> 的官方文档得知是通过拷贝指定的缓冲字节来创建 <code>CFData</code> 的：</p><blockquote><p>Creates an immutable CFData object using data copied from a specified byte buffer.</p></blockquote><p>虽然饶了一点，但是也算是找到好方法了，只要把 <code>let dataProvider = CGDataProviderCreateWithData(nil, imageBytes, Int(dataLength), nil)</code> 改成下面的代码就解决啦！</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = <span class="type">CFDataCreate</span>(<span class="literal">nil</span>, imageBytes, <span class="type">CFIndex</span>(dataLength))</span><br><span class="line"><span class="keyword">let</span> dataProvider = <span class="type">CGDataProviderCreateWithCFData</span>(data)</span><br><span class="line">imageBytes.destroy()</span><br><span class="line">imageBytes.dealloc(<span class="type">Int</span>(dataLength))</span><br></pre></td></tr></table></figure><p>最终代码：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">snapshotForEAGLView</span><span class="params">(glView: UIView)</span></span> -&gt; <span class="type">UIImage</span> &#123;</span><br><span class="line">   <span class="keyword">var</span> width: <span class="type">GLint</span> = <span class="number">0</span>, height: <span class="type">GLint</span> = <span class="number">0</span></span><br><span class="line">   <span class="keyword">let</span> scale: <span class="type">CGFloat</span> = <span class="type">UIScreen</span>.mainScreen().scale</span><br><span class="line">   <span class="keyword">let</span> prevGLContext = <span class="type">EAGLContext</span>.currentContext()</span><br><span class="line">   <span class="comment">// glView 有个 _colorRenderBuffer 属性(由于 glView 是第三方库的视图，所以只能通过这种方法来获取 _colorRenderBuffer)，需要将它与 GL_RENDERBUFFER 绑定，否则出现的截图可能是另外一个 OpenGL 视图</span></span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">let</span> colorRenderBuffer = glView.valueForKeyPath(<span class="string">"_colorRenderBuffer"</span>) <span class="keyword">as</span>? <span class="type">Int</span> &#123;</span><br><span class="line">       glBindRenderbuffer(<span class="type">GLenum</span>(<span class="type">GL_RENDERBUFFER</span>), <span class="type">GLuint</span>(colorRenderBuffer))</span><br><span class="line"></span><br><span class="line">       glGetRenderbufferParameteriv(<span class="type">GLenum</span>(<span class="type">GL_RENDERBUFFER</span>), <span class="type">GLenum</span>(<span class="type">GL_RENDERBUFFER_WIDTH</span>), &amp;width)</span><br><span class="line">       glGetRenderbufferParameteriv(<span class="type">GLenum</span>(<span class="type">GL_RENDERBUFFER</span>), <span class="type">GLenum</span>(<span class="type">GL_RENDERBUFFER_HEIGHT</span>), &amp;height)</span><br><span class="line"></span><br><span class="line">       <span class="comment">// glView 有个 _context 属性，需要将它设置成当前的 EAGLContext，并且执行 presentRenderbuffer 方法用来把 CAEAGLLayer 渲染出来</span></span><br><span class="line">       <span class="keyword">if</span> <span class="keyword">let</span> glContext = glView.valueForKeyPath(<span class="string">"_context"</span>) <span class="keyword">as</span>? <span class="type">EAGLContext</span> &#123;</span><br><span class="line">           <span class="type">EAGLContext</span>.setCurrentContext(glContext)</span><br><span class="line">           glContext.presentRenderbuffer(<span class="type">Int</span>(<span class="type">GL_RENDERBUFFER</span>)) <span class="comment">// 显示当前 view 的 CAEAGLLayer</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       width = <span class="type">GLint</span>(glView.bounds.width * scale)</span><br><span class="line">       height = <span class="type">GLint</span>(glView.bounds.height * scale)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> dataLength = width * height * <span class="number">4</span></span><br><span class="line">   <span class="keyword">let</span> imageBytes = <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">GLubyte</span>&gt;.alloc(<span class="type">Int</span>(dataLength))</span><br><span class="line">   <span class="comment">// 将图像信息存入内存</span></span><br><span class="line">   glPixelStorei(<span class="type">GLenum</span>(<span class="type">GL_PACK_ALIGNMENT</span>), <span class="number">4</span>)</span><br><span class="line">   <span class="comment">// 读取图像的像素信息并写入到 imageBytes</span></span><br><span class="line">   glReadPixels(<span class="number">0</span>, <span class="number">0</span>, <span class="type">GLsizei</span>(width), <span class="type">GLsizei</span>(height), <span class="type">GLenum</span>(<span class="type">GL_RGBA</span>), <span class="type">GLenum</span>(<span class="type">GL_UNSIGNED_BYTE</span>), imageBytes)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> data = <span class="type">CFDataCreate</span>(<span class="literal">nil</span>, imageBytes, <span class="type">CFIndex</span>(dataLength))</span><br><span class="line">   <span class="keyword">let</span> dataProvider = <span class="type">CGDataProviderCreateWithCFData</span>(data)</span><br><span class="line">   imageBytes.destroy()</span><br><span class="line">   imageBytes.dealloc(<span class="type">Int</span>(dataLength))</span><br><span class="line"></span><br><span class="line">   <span class="type">EAGLContext</span>.setCurrentContext(prevGLContext)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">let</span> colorSpace = <span class="type">CGColorSpaceCreateDeviceRGB</span>()</span><br><span class="line">   <span class="keyword">if</span> <span class="keyword">let</span> imageRef = <span class="type">CGImageCreate</span>(<span class="type">Int</span>(width), <span class="type">Int</span>(height), <span class="number">8</span>, <span class="number">32</span>, <span class="type">Int</span>(width) * <span class="number">4</span>, colorSpace, [<span class="type">CGBitmapInfo</span>.<span class="type">ByteOrder32Big</span>, <span class="type">CGBitmapInfo</span>(rawValue: <span class="type">CGImageAlphaInfo</span>.<span class="type">PremultipliedLast</span>.rawValue)], dataProvider, <span class="literal">nil</span>, <span class="literal">true</span>, <span class="type">CGColorRenderingIntent</span>.<span class="type">RenderingIntentDefault</span>) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="type">UIImage</span>(<span class="type">CGImage</span>: imageRef, scale: scale, orientation: .<span class="type">DownMirrored</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="keyword">return</span> <span class="type">UIImage</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;由于业务需求，需要对两个（现在是三个了）中的一个 OpenGL 渲染的视图进行截图并增加模糊效果。开始用传统的方法进行截图，但是失败了（截取的是黑屏还是空白，忘记了。。。），后来意识到这个和一般的视图应该是不一样的，就到  Google 上搜了一下。由于没怎么玩过，又不怎么懂，就直接翻译成 &lt;code&gt;Swift&lt;/code&gt; 了。开始是没发现什么问题的，都是但是到后来发现截图总是其中一个的（看那个先出来，基本上不是想要的那个），而不是想要的那个。&lt;/p&gt;
&lt;p&gt;仔细研究后发现，OpenGL 的截图是根据 RenderBuffer 来截取的，由于没有指定 RenderBuffer 所以截取的图只是其中某一个。知道了这个也没用，由于这个 View 用的是第三方库，所以不知道这个 View 的 RenderBuffer。。。后果经过 Debug，发现这个 View 有个 &lt;code&gt;_colorRenderBuffer&lt;/code&gt; 属性，这就好办啦~。经过改造后代码如下：&lt;/p&gt;
    
    </summary>
    
      <category term="Swift" scheme="http://firestudio.cn/categories/swift/"/>
    
    
      <category term="OpenGL" scheme="http://firestudio.cn/tags/opengl/"/>
    
      <category term="Screenshots" scheme="http://firestudio.cn/tags/screenshots/"/>
    
      <category term="EAGLView" scheme="http://firestudio.cn/tags/eaglview/"/>
    
  </entry>
  
  <entry>
    <title>从 Octopress 迁移到 Hexo 后的一些遗留问题</title>
    <link href="http://firestudio.cn/2016/03/03/remaining-issues-after-migrated-from-octopress-to-hexo/"/>
    <id>http://firestudio.cn/2016/03/03/remaining-issues-after-migrated-from-octopress-to-hexo/</id>
    <published>2016-03-03T10:00:12.000Z</published>
    <updated>2019-03-27T14:23:09.917Z</updated>
    
    <content type="html"><![CDATA[<p>上周我讲自己的博客从 Octopress 迁移到了 Hexo，感觉还是很不错的，但是由于Octopress 和 Hexo 存在一些差别，所以导致了如下三个问题：</p><ol><li>以前 Octopress 的网址是包含 /blog/ 的，迁移之后没了，这样会导致由搜索引擎（搜索引擎更新还是很不及时的）的链接和外网引用的链接点过来会跳到404页面</li><li>生成的网址区分大小写了，以前全部是小写的，这会导致以前的小写链接无法打开相应的页面（如 <code>categories/xcode</code>，现在是 <code>categories/Xcode</code>）</li><li>之前的一些文件遗失了（其实也就一个）</li></ol><p>今天就来说一下我是怎么解决这三个问题：</p><a id="more"></a><h3 id="第一个问题"><a class="markdownIt-Anchor" href="#第一个问题"></a> 第一个问题</h3><p>需要自定义一个 404 页面（在 <code>source</code> 目录下创建一个 404 页面_<a href="http://ibruce.info/2013/11/22/hexo-your-blog/#404%E9%A1%B5%E9%9D%A2" target="_blank" rel="noopener">参考</a>_）。本来想做一下404公益的，但是由于<a href="http://www.qq.com/404" target="_blank" rel="noopener">腾讯公益404</a>是完全替换了我的404页面的内容，无法达到我的效果，所以舍弃了；<a href="http://yibo.iyiyun.com/Index/web404" target="_blank" rel="noopener">404公益_益云(公益互联网)社会创新中心</a>倒是可以，但是在没有适应移动设备（宽高限定死了），所以也舍弃了；<a href="http://404page.missingkids.org.tw/" target="_blank" rel="noopener">失蹤兒童少年資料管理中心404</a>是台湾的网站，没有试，所以也舍弃了。</p><p>创建好页面之后在文件中写入如下内容：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 页面没有找到</span><br><span class="line">description: 页面没有找到</span><br><span class="line">comments: false # 关闭评论功能</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>页面没有找到<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"back-link"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/"</span>&gt;</span>返回主页<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  var originalLocation = window.location;</span></span><br><span class="line"><span class="undefined">  if (originalLocation.pathname.indexOf('/blog/') == 0) &#123;</span></span><br><span class="line"><span class="undefined">    var originalHref = originalLocation.href;</span></span><br><span class="line"><span class="undefined">    var pathIndex = originalHref.indexOf(location.pathname);</span></span><br><span class="line"><span class="undefined">    // 因为 /blog/ 长度是 6，而且包含了两个 /，所以要减掉一个常晒</span></span><br><span class="line"><span class="undefined">    var newHref = originalHref.substr(0, pathIndex) + originalHref.substr(pathIndex + 5)</span></span><br><span class="line"><span class="undefined">    var liTag = document.createElement('li');</span></span><br><span class="line"><span class="undefined">    var aTag = document.createElement('a');</span></span><br><span class="line"><span class="undefined">    aTag.setAttribute('href', newHref);</span></span><br><span class="line"><span class="undefined">    aTag.text = '也可能移到了这里：' + newHref;</span></span><br><span class="line"><span class="undefined">    liTag.appendChild(aTag);</span></span><br><span class="line"><span class="undefined">    var blankLink = document.getElementById('back-link');</span></span><br><span class="line"><span class="undefined">    blankLink.appendChild(liTag);</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>之后再重新生成和发布就可以了。</p><p>上述代码的作用就是现实一个无序列表，里面有一条“返回主页”链接，通过 js 判断当前网址的路径是否以 <code>/blog/</code> 开头，如果是则创建一个链接，把 <code>/blog/</code> 去掉并生成新的网址插入到无序列表中。</p><h3 id="第二个问题"><a class="markdownIt-Anchor" href="#第二个问题"></a> 第二个问题</h3><p>首先需要改一下配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将此选项设置成 1， 设置成 1 的意思是全部转成小写</span></span><br><span class="line"><span class="attr">filename_case:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure><p>如果之前有部署再传上去是会有问题的，虽然之前的大写字母现在已经全部换成了小写，但是传不到 <a href="https://github.com" target="_blank" rel="noopener">Github</a> 上，可能是 git 忽略了大小写吧。我的方法是直接把原来的仓库删掉重建一遍，然后再上传，反正也无所谓（本地记得删除 <code>.deploy_git</code> 目录和执行 <code>hexo clean</code> 命令）。</p><h3 id="第三个问题"><a class="markdownIt-Anchor" href="#第三个问题"></a> 第三个问题</h3><p>这个问题就更简单了，直接找到原来的网站备份，把遗失的文件和目录上传到相应的地方（<code>source</code> 目录下）就行了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周我讲自己的博客从 Octopress 迁移到了 Hexo，感觉还是很不错的，但是由于Octopress 和 Hexo 存在一些差别，所以导致了如下三个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;以前 Octopress 的网址是包含 /blog/ 的，迁移之后没了，这样会导致由搜索引擎（搜索引擎更新还是很不及时的）的链接和外网引用的链接点过来会跳到404页面&lt;/li&gt;
&lt;li&gt;生成的网址区分大小写了，以前全部是小写的，这会导致以前的小写链接无法打开相应的页面（如 &lt;code&gt;categories/xcode&lt;/code&gt;，现在是 &lt;code&gt;categories/Xcode&lt;/code&gt;）&lt;/li&gt;
&lt;li&gt;之前的一些文件遗失了（其实也就一个）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;今天就来说一下我是怎么解决这三个问题：&lt;/p&gt;
    
    </summary>
    
      <category term="Other" scheme="http://firestudio.cn/categories/other/"/>
    
    
      <category term="Octopress" scheme="http://firestudio.cn/tags/octopress/"/>
    
      <category term="Hexo" scheme="http://firestudio.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>从 Octopress 迁移到 Hexo</title>
    <link href="http://firestudio.cn/2016/02/26/migrate-from-octopress-to-hexo/"/>
    <id>http://firestudio.cn/2016/02/26/migrate-from-octopress-to-hexo/</id>
    <published>2016-02-26T06:16:24.000Z</published>
    <updated>2019-04-02T17:44:25.221Z</updated>
    
    <content type="html"><![CDATA[<p>很久没写过日志了，原因没有别的，实在是鄙人太！懒！了！自己也想不能继续懒下去，所以决定改变从这里开始，先换个静态博客生成系统吧。好吧~，换系统其实和这个没多大关系，主要是因为 Octopress 已经 N 久没有更新了，还有就是对于一个 N 久没有写过博客的人来说，再用 <a href="http://octopress.org" target="_blank" rel="noopener">Octopress</a> 需要重新熟悉一下，相比之下 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 就简单多了，还有就是据说生成速度上 <a href="http://octopress.org" target="_blank" rel="noopener">Octopress</a> 要比 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 慢一大截。下面介绍一下 Mac 下 Hexo 的安装过程吧~</p><a id="more"></a><h3 id="安装-nodejs-与-hexo"><a class="markdownIt-Anchor" href="#安装-nodejs-与-hexo"></a> 安装 Node.js 与 Hexo</h3><p>建议通过 <a href="http://brew.sh" target="_blank" rel="noopener">Homebrew</a> 安装，原因是安装、升级和删除简单方便。当然也可以通过官网的安装包，但是通过安装包安装会有个问题，由于 <code>/usr/local/lib/dtrees</code> 和 <code>/usr/local/lib/node_modules</code> 目录的属主是 root:wheel 而不是当前用户，所以在执行 <code>npm install hexo-cli -g</code> 的时候会无法写入 <code>/usr/local/lib/node_modules</code> 而导致安装失败。如果用了 <code>sudo</code> 会有本地没有安装 <code>hexo</code> 的错误，让执行 <code>npm install hexo --save</code> 命令，因此也无法使用。</p><p>通过上述方法安装完 <a href="https://nodejs.org" target="_blank" rel="noopener">Node.js</a> 之后执行 <code>npm install -g hexo-cil</code> 即可完成安装。</p><h3 id="常用的命令"><a class="markdownIt-Anchor" href="#常用的命令"></a> 常用的命令</h3><ul><li><code>hexo init [blog directory name]</code> 初始化博客目录，如果后面目录名没有指定则是当前目录</li><li><code>hexo g[enerate]</code> 生成静态文件</li><li><code>hexo config</code> 获取和配置你的博客，可以通过 <code>_config.yml</code> 来直接更改配置（推荐！因为比较直观，但是要对 <a href="http://yaml.org" target="_blank" rel="noopener">Yaml</a> 格式有一定的了解，当然也是非常简单的）</li><li><code>hexo n[ew] &lt;[post]|page&gt; &lt;title&gt;</code> 创建文章或页面</li><li><code>hexo s[erver]</code> 建立并开启本地服务器，默认网址是 <a href="http://0.0.0.0:4000" target="_blank" rel="noopener">http://0.0.0.0:4000</a></li><li><code>hexo d[eploy]</code> 部署博客</li><li><code>hexo m[igrate]</code> 从其他平台迁移到 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a></li><li><code>hexo --help</code> 显示帮助，可以查看别的命令的帮助</li></ul><h3 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h3><p><a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 的配置也是很简单的，只需要简单配置如下选项即可（其他的根据需要自己选择性的改一改就行了）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Site，网站基本信息相关的内容</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Fire</span> <span class="string">Studio</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">记录，学习，成长</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">iOS</span> <span class="string">Developer</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Yozone</span> <span class="string">Wang</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-Hans</span></span><br><span class="line"><span class="attr">timezone:</span> <span class="string">Asia/Shanghai</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># URL，网站网址</span></span><br><span class="line"><span class="comment">## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'</span></span><br><span class="line"><span class="attr">url:</span> <span class="attr">http://firestudio.cn</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extensions</span></span><br><span class="line"><span class="comment">## Plugins: https://hexo.io/plugins/</span></span><br><span class="line"><span class="comment">## Themes: https://hexo.io/themes/ ，可以到这里查看和使用别的主题，</span></span><br><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Deployment 部署，最主要的，但是也很简单</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/deployment.html</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">git</span></span><br><span class="line"><span class="attr">  repo:</span> <span class="string">git@github.com:azone/azone.github.io.git</span></span><br></pre></td></tr></table></figure><p>预览之后才发现 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 不支持对 <a href="http://yaml.org" target="_blank" rel="noopener">Yaml</a> 格式代码的高亮。</p><h3 id="迁移与部署"><a class="markdownIt-Anchor" href="#迁移与部署"></a> 迁移与部署</h3><p>由于我之前用的是 <a href="http://octopress.org" target="_blank" rel="noopener">Octopress</a> 而且他们的格式是相互兼容的，所以最简单的办法是只需要把之前 <a href="http://octopress.org" target="_blank" rel="noopener">Octopress</a> 下 <code>_post</code> 目录拷贝到 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 即可。但是有一点需要注意，一定要将之前的 <code>.markdown</code> 后缀改成 <code>.md</code>，否则文章生成的地址会是 <code>/yyyy/MM/dd/yyyy-MM-dd-title</code> 而不是 <code>/yyyy/MM/dd/title</code></p><p>如果是通过 git 或者 Github 部署的，则需要通过<code>npm install hexo-deployer-git --save</code>先安装 hexo-deployer-git 插件。</p><p>当然也可以安装 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 提供的 <a href="http://hexo.io/plugins" target="_blank" rel="noopener">插件</a> ，然后通过 <code>hexo m[igrate] &lt;type&gt;</code> 迁移，最后通过 <code>hexo d[eploy]</code> 来部署。</p><h3 id="我安装的几个插件"><a class="markdownIt-Anchor" href="#我安装的几个插件"></a> 我安装的几个插件</h3><p>由于今天才开始部署 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a>，所以对 <a href="https://hexo.io" target="_blank" rel="noopener">Hexo</a> 的插件了解的也不是太多，只装了几个：</p><ul><li><a href="https://github.com/hexojs/hexo-deployer-git" target="_blank" rel="noopener">hexo-deployer-git</a>，通过 <a href="http://git-scm.com" target="_blank" rel="noopener">GIT</a> 部署博客</li><li><a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">hexo-generator-feed</a>，生成订阅</li><li><a href="https://github.com/hexojs/hexo-generator-category" target="_blank" rel="noopener">hexo-generator-category</a>，生成分类</li><li><a href="https://github.com/hexojs/hexo-generator-sitemap" target="_blank" rel="noopener">hexo-generator-sitemap</a>，生成网站地图</li><li><a href="https://github.com/JamesPan/hexo-ruby-character" target="_blank" rel="noopener">hexo-ruby-character</a>，<ruby>为了好玩<rp> (</rp><rt>wèi le hǎo wán</rt><rp>) </rp></ruby>装了这个插件😄</li><li><s><a href="https://github.com/akfish/hexo-math" target="_blank" rel="noopener">hexo-math</a> 显示数学方程式和符号等</s> (已使用主题自带功能) $$\sum_{i=1}^n$$</li></ul><h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3><p>该说的上面已经说了，总的来说还是很棒的。最后决定把评论系统从 <a href="https://disqus.com" target="_blank" rel="noopener">Disqus</a> 迁移到<a href="http://duoshuo.com" target="_blank" rel="noopener">多说</a>，毕竟多说是国内的，速度应该会快很多，Disqus 说不定哪天就被墙了。由于评论内容前一起来非常麻烦，而且评论内容非常少，所以决定评论内容就不迁移了。不说了，走起~</p><hr><p><em>注意：文章中方括号中括起来的部分为可选部分</em></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;很久没写过日志了，原因没有别的，实在是鄙人太！懒！了！自己也想不能继续懒下去，所以决定改变从这里开始，先换个静态博客生成系统吧。好吧~，换系统其实和这个没多大关系，主要是因为 Octopress 已经 N 久没有更新了，还有就是对于一个 N 久没有写过博客的人来说，再用 &lt;a href=&quot;http://octopress.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Octopress&lt;/a&gt; 需要重新熟悉一下，相比之下 &lt;a href=&quot;https://hexo.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt; 就简单多了，还有就是据说生成速度上 &lt;a href=&quot;http://octopress.org&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Octopress&lt;/a&gt; 要比 &lt;a href=&quot;https://hexo.io&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt; 慢一大截。下面介绍一下 Mac 下 Hexo 的安装过程吧~&lt;/p&gt;
    
    </summary>
    
      <category term="Other" scheme="http://firestudio.cn/categories/other/"/>
    
    
      <category term="Octopress" scheme="http://firestudio.cn/tags/octopress/"/>
    
      <category term="Hexo" scheme="http://firestudio.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>如何运用更聪明的办法进行Core Data数据迁移</title>
    <link href="http://firestudio.cn/2014/04/04/how-to-make-core-data-migration-smarter/"/>
    <id>http://firestudio.cn/2014/04/04/how-to-make-core-data-migration-smarter/</id>
    <published>2014-04-04T14:49:25.000Z</published>
    <updated>2019-03-27T14:23:09.916Z</updated>
    
    <content type="html"><![CDATA[<p>这一段时间一个Core Data数据迁移的问题快把我搞死了，上面给的压力也非常大。先说一下来龙去脉吧~</p><h2 id="第一次犯错"><a class="markdownIt-Anchor" href="#第一次犯错"></a> 第一次犯错</h2><p>首先以我为主程的一个应用（绝大部分代码是我写的）由于之前数据库设计的不合理导致应用总是无规律可循的崩溃。这个问题一直存在了好几个月，怎么研究都是无果。后来直到看到Stack Overflow上<a href="http://stackoverflow.com/a/20446844/397718" target="_blank" rel="noopener">Core Data: EXC_BAD_ACCESS accessing relationship</a>的帖子（后来还看到这个<a href="http://stackoverflow.com/a/6327448/" target="_blank" rel="noopener">Semantic Issue: Property’s synthesized getter follows Cocoa naming convention for returning ‘owned’ objects</a>）才意识到自己的愚蠢和无知！我忘记了Objective-C的属性名（Core Data中包括属性名和关系名）不能以new打头，否则就违反了Objective-C的<a href="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html" target="_blank" rel="noopener">内存管理策略</a>。</p><p><strong>请记住：尽量不要使用以alloc、new、copy和mutableCopy等打头的属性名、关系名和方法名，如果必须使用请在声明中使用<code>NS_RETURNS_RETAINED</code>或<code>NS_RETURNS_NOT_RETURNED</code>，否则会导致内存管理问题！！！</strong></p><a id="more"></a><h2 id="第二次犯错"><a class="markdownIt-Anchor" href="#第二次犯错"></a> 第二次犯错</h2><p>既然知道了错了那就改吧！于是就对Core Data的字段进行修改。之前只是大致了解过Core Data数据库迁移的基本知识，之前也做过一些（只不过之前都是轻量级迁移）。直到这次改关系名是个重量级的迁移，所以就以我自己的理解做了个mapping model。结果把<code>Relationship Mappings</code>中的<code>Mapping Name</code>给搞错了，搞成它自己了~。最终导致应用上架后升级用户大面积崩溃，后果很严重，老板和领导很生气。后来应用直接下架了，据说公司损失严重，还说开发的能力不行，给我制造了不少压力。</p><h2 id="第三次犯错"><a class="markdownIt-Anchor" href="#第三次犯错"></a> 第三次犯错</h2><p>既然有知道原因了那就及时改正吧~，更正了<code>Relationship Mappings</code>中的<code>Mapping Name</code>，然后经过粗略的测试紧急上架。这次走了苹果的加急通道，上架速度果然很快~，但是第二天又有很多人反馈崩溃问题，看了Crashlytics的后台，发现全是iOS 6及以下的设备。最终研究后发现当用户本地数据库数据量比较大的时候老版本升上来很多都会崩溃（性能好一点机器的几率比较小），后来找到原因了，我又犯了一个低级的错误！当时没考虑到很多人数据量比较大，没不清楚Core Data进行重量级迁移的时候需要耗费很久的时间。我把Core Data的自动迁移放到了应用的入口函数，阻碍了入口函数的返回，导致应用启动时间过长直接被系统咔嚓掉了，也有一部分用户由于迁移失败导致数据库数据残缺导致的崩溃。</p><h2 id="深入的研究"><a class="markdownIt-Anchor" href="#深入的研究"></a> 深入的研究</h2><p>以前买过一本Marcus S. Zarra的书<a href="http://pragprog.com/book/mzcd2/core-data" target="_blank" rel="noopener">Core Data (2nd edition): Data Storage and Management for iOS, OS X, and iCloud</a>，只是看了部分内容而且Core Data数据迁移这一块没怎么看。这次翻来自己看了一下，对一些概念搞清楚了，后来有看到<a href="http://objc.io" target="_blank" rel="noopener">objc.io</a>上的<a href="http://www.objc.io/issue-4/core-data-migration.html" target="_blank" rel="noopener">Custom Core Data Migrations</a>（里面也引用到了一部分<a href="http://pragprog.com/book/mzcd2/core-data" target="_blank" rel="noopener">Core Data (2nd edition): Data Storage and Management for iOS, OS X, and iCloud</a>中的代码）和 <a href="https://github.com/hwaxxer/BookMigration" target="_blank" rel="noopener">BookMigration</a>实例。都讲到了Progressive Migrations，搞的我也想尝试一下手动的数据迁移。于是有搜索了Google、StackOverflow和苹果文档等，最后发现mapping model是可以拆分的，也就是说一次升级可以拆分成多个mapping model(<strong>每个mapping model不能和另外的mapping model有任何关系，逻辑上要是独立的</strong>)，这样可以减少内存开支。在<a href="https://github.com/hwaxxer/BookMigration" target="_blank" rel="noopener">BookMigration</a>中又发现NSMigrationManager有一个migrationProgress属性，用来获取当前迁移进度，感觉真是太棒了，不用一直在那里转菊花了。。。</p><p>经过我自己的深入研究（实践）发现<code>+[NSMappingModel mappingModelFromBundles:forSourceModel:destinationModel:]</code>不是真正的靠source model和destination model来匹配的，而是通过mapping model与source model还有destination model的entity version hashes来进行对比的，而且它也只返回一个mapping model，如果拆分成多个mapping model的话就无法找到其他的了。而<code>+[NSManagedObjectModel mergedModelFromBundles:forStoreMetadata:]</code>也不是找出下一个版本的model，而是如果发现有<code>+[NSMappingModel mappingModelFromBundles:forSourceModel:destinationModel:]</code>和当前（source）model匹配的话就会返回那个model。</p><h2 id="进行改进"><a class="markdownIt-Anchor" href="#进行改进"></a> 进行改进</h2><p>后来我想到了一个绝佳的迁移Core Data数据库的方法：如果是轻量级迁移则用轻量级迁移，否则进行重量级迁移的逐步迁移方法，这样就可以用极少的mapping model做大跨度的版本迁移了。摸清了这些就可以对上述的实例进行一些改造了</p><ol><li>首先将原来的一个mapping model分成两个（这两个在逻辑上是相互独立的）；</li><li>将每个Core Data的model文件按照版本进行1、2、3、4等进行标示（1表示第一个版本，2表示第二个版本……），这样做的目的是方便由source（当前的） model找到其下一个版本的model；<br><img src="https://farm4.staticflickr.com/3792/13716379303_bd0a494373_o_d.png" alt="version identivers"></li><li>通过当前的model找到下一个版本的model；</li><li>找到所有的mapping model：遍历bundle中的每一个cdm文件（mapping model的二进制文件）并通过<code>-[NSMappingModel initWithContentsOfURL:]</code>生成NSMappingModel对象,将source model与destination model的entity version hashes与mapping model的<code>sourceEntityVersionHash</code>和<code>destinationEntityVersionHash</code>进行对比。如果mapping model等于或是source model和destination的子集则说明这个mapping model是升级到下一个版本的mapping model</li><li>如果找到的所有mapping model的<code>sourceEntityVersionHash</code>与<code>destinationEntityVersionHash</code>交集等于source model与destination model的entity version hashes则说明这是个重量级的迁移，否则说明出轻量级迁移。</li></ol><p>具体方法请参见：<a href="https://github.com/azone/WYZCoreDataMigrationManager" target="_blank" rel="noopener">WYZCoreDataMigrationManager</a>，觉得还是有一些地方需要改进的，只能等后面有机会再改进了。</p><p>另外还需要一些值得注意的地方，比如如果之前的Core Data的journal_mode是WAL，迁移的时候也要吧shm文件和wal文件一块迁移，否则可能会导致数据会乱；有时候需要自己定义Migration Policy等，我在这里就不多说了，实际情况还是需有具体问题具体对待。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这一段时间一个Core Data数据迁移的问题快把我搞死了，上面给的压力也非常大。先说一下来龙去脉吧~&lt;/p&gt;
&lt;h2 id=&quot;第一次犯错&quot;&gt;&lt;a class=&quot;markdownIt-Anchor&quot; href=&quot;#第一次犯错&quot;&gt;&lt;/a&gt; 第一次犯错&lt;/h2&gt;
&lt;p&gt;首先以我为主程的一个应用（绝大部分代码是我写的）由于之前数据库设计的不合理导致应用总是无规律可循的崩溃。这个问题一直存在了好几个月，怎么研究都是无果。后来直到看到Stack Overflow上&lt;a href=&quot;http://stackoverflow.com/a/20446844/397718&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Core Data: EXC_BAD_ACCESS accessing relationship&lt;/a&gt;的帖子（后来还看到这个&lt;a href=&quot;http://stackoverflow.com/a/6327448/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Semantic Issue: Property’s synthesized getter follows Cocoa naming convention for returning ‘owned’ objects&lt;/a&gt;）才意识到自己的愚蠢和无知！我忘记了Objective-C的属性名（Core Data中包括属性名和关系名）不能以new打头，否则就违反了Objective-C的&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/mmRules.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;内存管理策略&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;请记住：尽量不要使用以alloc、new、copy和mutableCopy等打头的属性名、关系名和方法名，如果必须使用请在声明中使用&lt;code&gt;NS_RETURNS_RETAINED&lt;/code&gt;或&lt;code&gt;NS_RETURNS_NOT_RETURNED&lt;/code&gt;，否则会导致内存管理问题！！！&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://firestudio.cn/categories/ios/"/>
    
      <category term="Core Data" scheme="http://firestudio.cn/categories/ios/core-data/"/>
    
    
  </entry>
  
  <entry>
    <title>iOS下如何播放GIF动画</title>
    <link href="http://firestudio.cn/2014/01/17/iosxia-ru-he-bo-fang-gifdong-hua/"/>
    <id>http://firestudio.cn/2014/01/17/iosxia-ru-he-bo-fang-gifdong-hua/</id>
    <published>2014-01-17T14:19:39.000Z</published>
    <updated>2019-03-27T14:23:09.916Z</updated>
    
    <content type="html"><![CDATA[<p>几个月前无意中看到<a href="http://stackoverflow.com" target="_blank" rel="noopener">StackOverFlow</a>上的一个帖子<a href="http://stackoverflow.com/questions/14458299/how-to-get-suitable-cgimage-from-combined-tiff-for-display-scale" target="_blank" rel="noopener">How to get suitable CGImage from combined TIFF for display scale</a>了解到了<a href="https://developer.apple.com/library/ios/documentation/graphicsimaging/Reference/ImageIORefCollection/_index.html" target="_blank" rel="noopener">ImageIO</a>这个框架，看到它可以读取<a href="http://en.wikipedia.org/wiki/Tagged_Image_File_Format" target="_blank" rel="noopener">TIFF</a>中的单张图片，当时就想能不能读取<a href="http://en.wikipedia.org/wiki/GIF" target="_blank" rel="noopener">GIF</a>中的图片呢？后来进一步研究后发现答案是肯定的。后来就想哪天细研究一下吧，顺便写篇博客记录一下。没想到我是这么的懒~，昨天才终于研究好了顺便写了个项目<a href="https://github.com/azone/WYZGIFAnimationView" target="_blank" rel="noopener">WYZGIFAnimationView</a>开源到了<a href="https://github.com" target="_blank" rel="noopener">Github</a>上。</p><a id="more"></a><p><a href="http://en.wikipedia.org/wiki/GIF" target="_blank" rel="noopener">GIF</a>动画大家应该都知道，但是在iOS中却不能直接播放它，只能显示它的第一帧画面。iOS中可以使用<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIImageView_Class/Reference/Reference.html" target="_blank" rel="noopener">UIImageView</a>并通过其<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIImageView_Class/Reference/Reference.html#//apple_ref/occ/instp/UIImageView/animationImages" target="_blank" rel="noopener">animationImages</a>、<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIImageView_Class/Reference/Reference.html#//apple_ref/occ/instp/UIImageView/animationDuration" target="_blank" rel="noopener">animationDuration</a>和<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIImageView_Class/Reference/Reference.html#//apple_ref/occ/instp/UIImageView/animationRepeatCount" target="_blank" rel="noopener">animationRepeatCount</a>等属性来播放连续图片的动画。<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIImage_Class/Reference/Reference.html" target="_blank" rel="noopener">UIImage</a>在iOS 5.0之后增加了<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIImage_Class/Reference/Reference.html#//apple_ref/occ/clm/UIImage/animatedImageNamed:duration:" target="_blank" rel="noopener">+ animatedImageNamed:duration:</a>和<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIImage_Class/Reference/Reference.html#//apple_ref/occ/clm/UIImage/animatedImageWithImages:duration:" target="_blank" rel="noopener">+ UIImage animatedImageWithImages:duration:</a>等方法，通过这些方法创建的<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIImage_Class/Reference/Reference.html" target="_blank" rel="noopener">UIImage</a>对象赋值给<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIImageView_Class/Reference/Reference.html" target="_blank" rel="noopener">UIImageView</a>的<a href="https://developer.apple.com/library/ios/documentation/uikit/reference/UIImageView_Class/Reference/Reference.html#//apple_ref/occ/instp/UIImageView/image" target="_blank" rel="noopener">image</a>属性，同样也可以播放动画。</p><p>我们如果想播放<a href="http://en.wikipedia.org/wiki/GIF" target="_blank" rel="noopener">GIF</a>动画，其实要做的就是将<a href="http://en.wikipedia.org/wiki/GIF" target="_blank" rel="noopener">GIF</a>动画中的每一帧拿出来转化成UIImage，放到一个数组，然后在通过读取<a href="http://en.wikipedia.org/wiki/GIF" target="_blank" rel="noopener">GIF</a>每一帧的延时时间并累加得出一个总时长，做完以上两步之后在通过上面的方法就可以播放<a href="http://en.wikipedia.org/wiki/GIF" target="_blank" rel="noopener">GIF</a>动画了。但是通过这种方式创建的动画有一个缺点，因为<a href="http://en.wikipedia.org/wiki/GIF" target="_blank" rel="noopener">GIF</a>动画很有可能不是匀速动画，它的每一帧延时可能都会不同。于是<a href="https://github.com/azone/WYZGIFAnimationView" target="_blank" rel="noopener">WYZGIFAnimationView</a>诞生了，说到这里突然想到<a href="https://github.com/azone/WYZGIFAnimationView" target="_blank" rel="noopener">WYZGIFAnimationView</a>还没有支持这一点，我要赶紧修正一下啦~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;几个月前无意中看到&lt;a href=&quot;http://stackoverflow.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;StackOverFlow&lt;/a&gt;上的一个帖子&lt;a href=&quot;http://stackoverflow.com/questions/14458299/how-to-get-suitable-cgimage-from-combined-tiff-for-display-scale&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;How to get suitable CGImage from combined TIFF for display scale&lt;/a&gt;了解到了&lt;a href=&quot;https://developer.apple.com/library/ios/documentation/graphicsimaging/Reference/ImageIORefCollection/_index.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;ImageIO&lt;/a&gt;这个框架，看到它可以读取&lt;a href=&quot;http://en.wikipedia.org/wiki/Tagged_Image_File_Format&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;TIFF&lt;/a&gt;中的单张图片，当时就想能不能读取&lt;a href=&quot;http://en.wikipedia.org/wiki/GIF&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GIF&lt;/a&gt;中的图片呢？后来进一步研究后发现答案是肯定的。后来就想哪天细研究一下吧，顺便写篇博客记录一下。没想到我是这么的懒~，昨天才终于研究好了顺便写了个项目&lt;a href=&quot;https://github.com/azone/WYZGIFAnimationView&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;WYZGIFAnimationView&lt;/a&gt;开源到了&lt;a href=&quot;https://github.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Github&lt;/a&gt;上。&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://firestudio.cn/categories/ios/"/>
    
    
  </entry>
  
  <entry>
    <title>如何让你的iOS7应用支持键盘快捷键</title>
    <link href="http://firestudio.cn/2013/12/26/ru-he-rang-ni-de-ios7ying-yong-zhi-chi-jian-pan-kuai-jie-jian/"/>
    <id>http://firestudio.cn/2013/12/26/ru-he-rang-ni-de-ios7ying-yong-zhi-chi-jian-pan-kuai-jie-jian/</id>
    <published>2013-12-26T14:50:35.000Z</published>
    <updated>2019-03-27T15:44:31.394Z</updated>
    
    <content type="html"><![CDATA[<p>最近买了个罗技的光能无线键盘（<a href="http://www.amazon.cn/Logitech-%E7%BD%97%E6%8A%80-K760-%E5%A4%AA%E9%98%B3%E8%83%BD%E9%94%AE%E7%9B%98/dp/B008KW90OM/ref=sr_1_cc_1?s=aps&amp;ie=UTF8&amp;qid=1388078016&amp;sr=1-1-catcorr&amp;keywords=k760" target="_blank" rel="noopener">K760</a>）用来连接我的iOS设备，但是发现iOS所支持的快捷键太少了（特别是iPhone），而iPad也仅有那几款应用支持那可怜的几个快捷键。这使得我感觉iOS设备用键盘如同鸡肋。。。因为打字什么的还是要手点。</p><p>记得之前了解到iOS 7的UIResponder新增了keyCommands方法，于是今天就研究了一下API文档并且测试了一下，感觉真是太棒了~</p><p>下面介绍一下如何让应用支持外接键盘的快捷键，其实很简单！</p><a id="more"></a><p>首先要确保在需要实现键盘快捷键的ViewController中加入如下代码：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)canBecomeFirstResponder &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就是重写<code>UIViewController</code>的<code>- (NSArray *)keyCommands</code>方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)keyCommands &#123;</span><br><span class="line">    <span class="keyword">return</span> @[[<span class="built_in">UIKeyCommand</span> keyCommandWithInput:<span class="built_in">UIKeyInputEscape</span> modifierFlags:kNilOptions action:<span class="keyword">@selector</span>(escapeKeyPressed:)]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一步就是实现<code>UIKeyCommand</code>的<code>action</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)escapeKeyPressed:(<span class="built_in">UIKeyCommand</span> *)keyCommand &#123;</span><br><span class="line">    <span class="built_in">UIAlertView</span> *alertView = [[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="string">@"UIKeyCommand Demo"</span> message:[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@ pressed"</span>, keyCommand.input] delegate:<span class="literal">nil</span> cancelButtonTitle:<span class="string">@"Ok"</span> otherButtonTitles:<span class="literal">nil</span>];</span><br><span class="line">    [alertView show];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在试一下运行app，然后按一下<code>esc</code>键（模拟器下可以使用电脑的键盘），看一下效果~，怎么样？很棒吧！！！</p><p><strong>参考文档：</strong></p><ul><li><p><a href="https://developer.apple.com/Library/ios/documentation/UIKit/Reference/UIResponder_Class/Reference/Reference.html#jumpTo_5" target="_blank" rel="noopener">UIResponder的keyCommands</a> (<a href="dash://UIResponder%20keyCommands" target="_blank" rel="noopener">在 Dash 中打开</a>)</p></li><li><p><a href="https://developer.apple.com/Library/ios/documentation/UIKit/Reference/UIKeyCommand_class/Reference/Reference.html#//apple_ref/occ/cl/UIKeyCommand" target="_blank" rel="noopener">UIKeyCommand</a> (<a href="dash://UIKeyCommand" target="_blank" rel="noopener">在 Dash 中打开</a>)</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近买了个罗技的光能无线键盘（&lt;a href=&quot;http://www.amazon.cn/Logitech-%E7%BD%97%E6%8A%80-K760-%E5%A4%AA%E9%98%B3%E8%83%BD%E9%94%AE%E7%9B%98/dp/B008KW90OM/ref=sr_1_cc_1?s=aps&amp;amp;ie=UTF8&amp;amp;qid=1388078016&amp;amp;sr=1-1-catcorr&amp;amp;keywords=k760&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;K760&lt;/a&gt;）用来连接我的iOS设备，但是发现iOS所支持的快捷键太少了（特别是iPhone），而iPad也仅有那几款应用支持那可怜的几个快捷键。这使得我感觉iOS设备用键盘如同鸡肋。。。因为打字什么的还是要手点。&lt;/p&gt;
&lt;p&gt;记得之前了解到iOS 7的UIResponder新增了keyCommands方法，于是今天就研究了一下API文档并且测试了一下，感觉真是太棒了~&lt;/p&gt;
&lt;p&gt;下面介绍一下如何让应用支持外接键盘的快捷键，其实很简单！&lt;/p&gt;
    
    </summary>
    
      <category term="iOS" scheme="http://firestudio.cn/categories/ios/"/>
    
    
  </entry>
  
  <entry>
    <title>如何在博客中插入Liquid模板变量</title>
    <link href="http://firestudio.cn/2013/01/23/ru-he-zai-bo-ke-zhong-cha-ru-liquidmo-ban-bian-liang/"/>
    <id>http://firestudio.cn/2013/01/23/ru-he-zai-bo-ke-zhong-cha-ru-liquidmo-ban-bian-liang/</id>
    <published>2013-01-23T14:07:00.000Z</published>
    <updated>2019-03-27T18:28:59.064Z</updated>
    
    <content type="html"><![CDATA[<p>上周写了一篇博客《<a href="/2013/01/13/rang-octopresszai-xin-biao-qian-ye-zhong-da-kai-wai-lian/">让Octopress在新标签页中打开外链</a>》，里面嵌入了一段代码，但是里面有一个模板变量<code>{{ root_url }}</code>却怎么也显示不出来~，后来在Octpress的Issues页面问了一下才知道如何才能不把那些用来显示的代码块中的变量不被解析，具体看<a href="https://github.com/imathis/octopress/issues/941#issuecomment-12206038" target="_blank" rel="noopener">https://github.com/imathis/octopress/issues/941#issuecomment-12206038</a>或者Stack Overflow的<a href="http://stackoverflow.com/questions/3426182/how-to-escape-liquid-template-tags" target="_blank" rel="noopener">How to escape liquid template tags?</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上周写了一篇博客《&lt;a href=&quot;/2013/01/13/rang-octopresszai-xin-biao-qian-ye-zhong-da-kai-wai-lian/&quot;&gt;让Octopress在新标签页中打开外链&lt;/a&gt;》，里面嵌入了一段代码，但是里面有一个模板变量&lt;
      
    
    </summary>
    
      <category term="Other" scheme="http://firestudio.cn/categories/other/"/>
    
    
      <category term="Octopress" scheme="http://firestudio.cn/tags/octopress/"/>
    
  </entry>
  
  <entry>
    <title>如何高效的使用XCode</title>
    <link href="http://firestudio.cn/2013/01/23/ru-he-gao-xiao-de-shi-yong-xcode/"/>
    <id>http://firestudio.cn/2013/01/23/ru-he-gao-xiao-de-shi-yong-xcode/</id>
    <published>2013-01-23T12:52:00.000Z</published>
    <updated>2019-03-27T14:23:09.915Z</updated>
    
    <content type="html"><![CDATA[<p>上周看了WWDC 2012的Session 402 - Working Efficiently with Xcode，顺便记了一些笔记。看了之后才注意到很多Xcode的快捷键和特性都没用过或者说没想到过用<sub>，平时用的太死板，只是用了`+R`之类的快捷键。现在把上周整理的笔记贴上来吧</sub></p><a id="more"></a><ul><li><code>⌘+0</code> 显示/隐藏导航栏</li><li><code>⌥+⌘+0</code> 显示/隐藏工具栏</li><li><code>⇧+⌘+O</code> 快速打开</li><li><code>⌘+单击</code> 在主编辑器中显示定义</li><li><code>⌥+⌘+单击</code> 在助手编辑器中显示定义</li><li><code>⌥+⌘+⏎</code> 显示助手编辑器</li><li><code>⌘+⏎</code> 隐藏助手编辑器</li><li>先按 <code>⌘+E</code> 再按 <code>⌘+G</code> 搜索当前所选文本，继续按<code>⌘+G</code>搜索下一个</li><li><code>⌃+⌥+⌘+2</code>打开代码片段库</li><li><code>⌘+J</code> 多个窗口之间切换</li><li><code>⌥+→/←</code> 先前/向后移动一个单词</li><li><code>⌃+b/f/n/p</code> 向前/向后移动一个字符，向上/向下移动一行</li><li><code>⌃+⌘+E</code> 当前编辑器全局编辑当前光标所在的变量名或方法名</li><li><code>⌃+⇧+⌘+/</code> 快速帮助</li><li><code>⌘+双击</code> 在新窗口中显示定义</li><li><code>⌃+⌥+⌘+J</code>在助手编辑器中显示定义</li><li>双击 <code>{</code> 选择代码块</li><li>搜索替换时按住 <code>⌥</code> 会将搜索栏的 “Replace All” 变成 “In Selection”</li><li>Xcode有 <strong>TODO</strong> 和 <strong>FIXME</strong> 功能，只需要在注释中写上<code>TODO: xxx</code>或者<code>FIXME: xxx</code>即可</li></ul><p>他们在视频中介绍了一个Automator服务，通过这个服务来达到对引入的头文件进行排序和过滤重复的功能，方法很简单，具体设置见图：</p><p><a href="http://www.flickr.com/photos/92204252@N08/8408600186/" target="_blank" rel="noopener"><img src="http://farm9.staticflickr.com/8186/8408600186_3c8f005426_z.jpg" alt="sort | uniq"></a></p><p>另外在这个视频中他们还介绍了Behavior、Tab和新窗口等的使用技巧来提高效率，很值得一看。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上周看了WWDC 2012的Session 402 - Working Efficiently with Xcode，顺便记了一些笔记。看了之后才注意到很多Xcode的快捷键和特性都没用过或者说没想到过用&lt;sub&gt;，平时用的太死板，只是用了`+R`之类的快捷键。现在把上周整理的笔记贴上来吧&lt;/sub&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Xcode" scheme="http://firestudio.cn/categories/xcode/"/>
    
    
      <category term="xcode" scheme="http://firestudio.cn/tags/xcode/"/>
    
  </entry>
  
  <entry>
    <title>让Octopress在新标签页中打开外链</title>
    <link href="http://firestudio.cn/2013/01/13/rang-octopresszai-xin-biao-qian-ye-zhong-da-kai-wai-lian/"/>
    <id>http://firestudio.cn/2013/01/13/rang-octopresszai-xin-biao-qian-ye-zhong-da-kai-wai-lian/</id>
    <published>2013-01-13T11:30:00.000Z</published>
    <updated>2019-03-27T14:23:09.914Z</updated>
    
    <content type="html"><![CDATA[<p>今天发现Octopress一个小小的问题，就是无法将外链在新窗口中打开。于是就自己写了一小段javascript代码轻易的解决了这个问题。</p><a id="more"></a><p>代码如下：</p><script src="//gist.github.com/4523641.js?file=open-in-blank.js"></script><p>用法很简单：</p><ol><li>将上面的代码下载下来或者复制其内容；</li><li>保存到octopress目录的source/javascripts/子目录中；</li><li>修改source/_includes/custom/header.html，在下面插入如下代码即可：</li></ol><figure class="highlight html"><figcaption><span>source/_includes/custom/header.html</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"&#123;&#123; root_url &#125;&#125;/javascripts/open-in-blank.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;今天发现Octopress一个小小的问题，就是无法将外链在新窗口中打开。于是就自己写了一小段javascript代码轻易的解决了这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Other" scheme="http://firestudio.cn/categories/other/"/>
    
    
      <category term="Octopress" scheme="http://firestudio.cn/tags/octopress/"/>
    
  </entry>
  
  <entry>
    <title>OS X 下如何实现批量重命名文件</title>
    <link href="http://firestudio.cn/2013/01/13/os-x-xia-ru-he-shi-xian-pi-liang-zhong-ming-ming-wen-jian/"/>
    <id>http://firestudio.cn/2013/01/13/os-x-xia-ru-he-shi-xian-pi-liang-zhong-ming-ming-wen-jian/</id>
    <published>2013-01-12T17:01:00.000Z</published>
    <updated>2019-03-27T14:23:09.914Z</updated>
    
    <content type="html"><![CDATA[<p>Windows和Linux下批量重命名都是非常简单的（可以参考<a href="http://linux-wiki.cn/wiki/zh-hk/%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6" target="_blank" rel="noopener">批量重命名文件 - Linux Wiki</a>）。OS X当然也可以像Linux那样用命令行，但是又要通过<a href="http://mxcl.github.com/homebrew/" target="_blank" rel="noopener">Homebrew</a>或者<a href="http://www.macports.org/" target="_blank" rel="noopener">MacPorts</a>，对于很多人来说可能比较麻烦或者不会用命令行。我一直在想OS X这么高级的操作系统难道没有更好用的批量重命名的方法吗？答案是肯定的~</p><a id="more"></a><p>之前我一直没有用过系统自带的Automator这个强大的工具，更是没有想到要用，后来看了@ibuick的<a href="http://ibuick.com/online-store" target="_blank" rel="noopener">《OS X Mountain Lion高手进阶》</a>之后做一些操作之前总是先想一下能不能用Automator来代替我自动批量完成。下面了介绍一下怎么来通过Automator来做一个批量重命名的工具吧。</p><ol><li>打开Automator，在弹出的“选取文稿类型”框中选择“服务”，设置 【“服务”收到选定的】选“文件或文件夹”、【位于】选“Finder”；</li><li>在资源库中找到“给 Finder 项目重命名”，双击或拖到右边“工作流组装区”，<strong>记得勾选“工作流程运行时显示次操作”</strong>；</li><li>保存服务，将其命名为“批量重命名”</li></ol><p>最后让大家看一下设置截图：</p><p><a href="http://www.flickr.com/photos/92204252@N08/8372891419/" target="_blank" rel="noopener"><img src="http://farm9.staticflickr.com/8330/8372891419_8628bd032a_c.jpg" title="Automator设置"></a></p><p>以后如果想给文件批量重命名的时候只需要选择需要重命名的文件，然后选择“” -&gt; “服务”或者点击右键选择服务，找到“批量重命名”就可以了~</p><p><a href="http://www.flickr.com/photos/92204252@N08/8372922251/" target="_blank" rel="noopener"><img src="http://farm9.staticflickr.com/8329/8372922251_cc83e25b1e_z.jpg" title="执行效果图"></a></p><p>最后附上我制作的<a href="/uploads/files/batch-rename.workflow.zip">batch-rename.workflow.zip</a>，你可以下载之后解压，然后双击安装。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Windows和Linux下批量重命名都是非常简单的（可以参考&lt;a href=&quot;http://linux-wiki.cn/wiki/zh-hk/%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D%E6%96%87%E4%BB%B6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;批量重命名文件 - Linux Wiki&lt;/a&gt;）。OS X当然也可以像Linux那样用命令行，但是又要通过&lt;a href=&quot;http://mxcl.github.com/homebrew/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Homebrew&lt;/a&gt;或者&lt;a href=&quot;http://www.macports.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MacPorts&lt;/a&gt;，对于很多人来说可能比较麻烦或者不会用命令行。我一直在想OS X这么高级的操作系统难道没有更好用的批量重命名的方法吗？答案是肯定的~&lt;/p&gt;
    
    </summary>
    
      <category term="Automator" scheme="http://firestudio.cn/categories/automator/"/>
    
    
      <category term="批量重命名" scheme="http://firestudio.cn/tags/%E6%89%B9%E9%87%8F%E9%87%8D%E5%91%BD%E5%90%8D/"/>
    
      <category term="Automator" scheme="http://firestudio.cn/tags/automator/"/>
    
  </entry>
  
  <entry>
    <title>如何通过GitHub与Octopresss来搭建自己的博客</title>
    <link href="http://firestudio.cn/2013/01/05/ru-he-tong-guo-github-yu-octopress-lai-da-jian-zi-ji-de-bo-ke/"/>
    <id>http://firestudio.cn/2013/01/05/ru-he-tong-guo-github-yu-octopress-lai-da-jian-zi-ji-de-bo-ke/</id>
    <published>2013-01-05T13:05:00.000Z</published>
    <updated>2019-03-27T14:23:09.913Z</updated>
    
    <content type="html"><![CDATA[<p>现在通过<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>+<a href="http://octopress.org/" target="_blank" rel="noopener">Octopress</a>来搭建个人博客的越来越多了。这几天我也试着通过这个试着搭建一下，开始觉得很折腾，后来折腾出来之后发现还是买简单的。</p><p>通过<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>+<a href="http://octopress.org/" target="_blank" rel="noopener">Octopress</a>搭建的博客有几个很显而易见的有点：</p><a id="more"></a><ol><li>简单，虽然一开始觉得还是很复杂的，但是等搭建好一次之后发现还是很简单的；</li><li>完全免费，不需要考虑空间费用问题，甚至域名的费用也不用考虑；</li><li>空间够大，如果只写文字类的博客来说<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>提供1GB的空间，已经足够用了</li><li>插件多，<a href="http://octopress.org/" target="_blank" rel="noopener">Octopress</a>也有很多插件（包括<a href="http://jekyllrb.com/" target="_blank" rel="noopener">Jekyll</a>的插件），虽然不能和Wordpress比，但是也够用了~。如果自己有能力的话也可以自己写一些</li><li>有版本控制，随时恢复到以前任何一个版本</li><li>……</li></ol><p>废话不多说了，下面就介绍来一下博客的搭建过程。</p><h2 id="一些必要元素"><a class="markdownIt-Anchor" href="#一些必要元素"></a> 一些必要元素</h2><ul><li><a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>账号</li><li>Git环境</li><li>Ruby环境（1.9.3）</li><li>Markdown编辑器（用于写日志用）</li></ul><h3 id="注册github账号"><a class="markdownIt-Anchor" href="#注册github账号"></a> 注册GitHub账号</h3><p>这个很简单，只需要到<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>按照上面的提示注册就可以了</p><h3 id="搭建git环境"><a class="markdownIt-Anchor" href="#搭建git环境"></a> 搭建Git环境</h3><ul><li>如果是Mac的话建议用<a href="http://code.google.com/p/git-osx-installer/downloads/list" target="_blank" rel="noopener">Git OS X Installer</a></li><li>如果是Windows的话请下载<a href="http://code.google.com/p/msysgit/downloads/list?q=full+installer+official+git" target="_blank" rel="noopener">msysgit</a>并安装</li><li>如果是Linux<ul><li>Debian/Ubuntu：<code>sudo apt-get install git-core</code></li><li>CentOS/Redhat/Fedora： <code>sudo yum install git-core</code></li><li>其他Linux系统可以到<a href="http://git-scm.com" target="_blank" rel="noopener">Git官网</a>(需要翻墙)或者<a href="https://github.com/git/git" target="_blank" rel="noopener">GitHub</a>下载源代码进行编译安装</li></ul></li></ul><p>装好之后需要对git进行简单的配置（如果是Windows需要打开Git Shell）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email <span class="string">"your-email@example.com"</span></span><br><span class="line">git config --global user.name <span class="string">"Your Name Here"</span></span><br></pre></td></tr></table></figure><p>然后生成证书（如果是Windows需要打开Git Shell）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">"your-email@example.com or other message"</span></span><br></pre></td></tr></table></figure><p>然后拷贝~/.ssh/id_rsa.pub（Windows一般在C:\Users&lt;username&gt;.ssh\id_rsa.pub）的内容，登陆<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>，进入&quot;Account Settings&quot;，点击&quot;SSH Keys&quot;，再点&quot;Add SSH Keys&quot;，将id_rsa.pub的内容粘贴到&quot;Key&quot;中，并输入&quot;Title&quot;</p><h3 id="安装ruby"><a class="markdownIt-Anchor" href="#安装ruby"></a> 安装Ruby</h3><p>使用<a href="http://octopress.org/" target="_blank" rel="noopener">Octopress</a>需要Ruby版本为1.9.3，如果小于这个版本则无法使用。下面介绍一下如何安装Ruby~</p><p>如果你用的操作系统是非Windows则比较简单，强烈建议安装<a href="https://github.com/sstephenson/rbenv" target="_blank" rel="noopener">rbenv</a>或者<a href="https://rvm.io/" target="_blank" rel="noopener">RVM</a>，通过它们来安装ruby1.9.3，这样不会对你系统本身造成任何影响。以个人经验在Mac下安装Ruby比较麻烦一些。如果你之前安装过XCode4.1（必须装了Command Line Tools）或者之前的版本是比较简单的，否则需要先安装<code>apple-gcc42</code>，<code>apple-gcc42</code>你可以通过<a href="http://mxcl.github.com/homebrew/" target="_blank" rel="noopener">Homebrew</a>（<a href="https://github.com/mxcl/homebrew" target="_blank" rel="noopener">源代码</a>）或者<a href="http://kennethreitz.com/xcode-gcc-and-homebrew.html" target="_blank" rel="noopener">OSX GCC Installer</a>（<a href="https://github.com/kennethreitz/osx-gcc-installer" target="_blank" rel="noopener">源代码</a>）来安装。</p><p>如果你用的是Windows的话需要通过<a href="http://www.rubyinstaller.org/downloads/" target="_blank" rel="noopener">RubyInstaller</a>来安装安装Ruby，到上面的页面下载最新的Ruby和DevKit。首先安装Ruby（记得把Ruby加入到系统PATH变量，安装的时候有这个选项），然后双击解压下载的DevKit（自解压文件），通过命令提示符cd到解压的目录，执行<code>ruby dk.rb init</code>，然后再执行<code>ruby dk.rb install</code>，这样ruby就安装好了。</p><h3 id="markdown编辑器"><a class="markdownIt-Anchor" href="#markdown编辑器"></a> Markdown编辑器</h3><ul><li>Mac推荐用<a href="http://mouapp.com/" target="_blank" rel="noopener">Mou</a>，国人开发的，免费的，你可以向作者提供一些<a href="http://mouapp.com/donate/" target="_blank" rel="noopener">赞助</a></li><li>Windows可以用<a href="http://markdownpad.com/" target="_blank" rel="noopener">MarkdownPad</a></li><li>Linux就自己找吧，应该也比较多</li><li>除了以上介绍的几个编辑器之外，很多代码编辑器也支持</li></ul><h2 id="搭建你的blog"><a class="markdownIt-Anchor" href="#搭建你的blog"></a> 搭建你的Blog</h2><h3 id="配置与部署"><a class="markdownIt-Anchor" href="#配置与部署"></a> 配置与部署</h3><p>配置<a href="http://octopress.org/" target="_blank" rel="noopener">Octopress</a>其实还是蛮简单的，只要根据官网上的<a href="http://octopress.org/docs/" target="_blank" rel="noopener">文档</a>一步一步来就可以了。我就简要介绍一下步骤吧（Windows下要在Git Shell命令行中执行命令）~</p><p>首先要到<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>上创建一个仓库，仓库的名字是<code>&lt;username&gt;.github.com</code>，其中<code>&lt;username&gt;</code>是你的github上的用户名。创建好之后需要进入刚才建立的仓库，然后进入&quot;Settings&quot;，往下滚你会看到&quot;GitHub Pages&quot;，里面有个&quot;Automatic Page Generator&quot;按钮，点击它。然后是生成的首页和内容，别管它只需要点下面的&quot;Continue to Layouts&quot;按钮就行。接着就是选择模板，随便选一个然后按&quot;PUBLISH&quot;按钮即可。大约十分钟之后就可以看到通过&quot;Automatic Page Generator&quot;生成的页面了，当然这个你不需要管它，过一会会被<a href="http://octopress.org/" target="_blank" rel="noopener">Octopress</a>生成的静态页面给替换掉。</p><p>接下来就要把<a href="http://octopress.org/" target="_blank" rel="noopener">Octopress</a>克隆下来了，在终端输入如下命令（可以参考<a href="http://octopress.org/docs/setup/" target="_blank" rel="noopener">http://octopress.org/docs/setup/</a>）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/<span class="built_in">where</span>/you/want/to/<span class="built_in">clone</span></span><br><span class="line">git <span class="built_in">clone</span> https://github.com/imathis/octopress.git</span><br><span class="line"><span class="built_in">cd</span> octopress</span><br><span class="line"><span class="comment"># 安装依赖</span></span><br><span class="line">gem install bundler</span><br><span class="line">bundle install</span><br><span class="line"><span class="comment"># 安装Octopress默认的主题</span></span><br><span class="line">rake install</span><br></pre></td></tr></table></figure><p>然后是进行部署配置，执行命令（参考网址<a href="http://octopress.org/docs/deploying/github/" target="_blank" rel="noopener">http://octopress.org/docs/deploying/github/</a>）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rake setup_github_pages</span><br></pre></td></tr></table></figure><p>它会询问你并让你输入刚才所创建的仓库的地址：<code>git@github.com:&lt;username&gt;/&lt;username&gt;.github.com</code>，接下来是要配置一下你的_config.yml文件（参考网址：<a href="http://octopress.org/docs/configuring/" target="_blank" rel="noopener">http://octopress.org/docs/configuring/</a>），其实也比较简单，根据自己的实际情况修改一下就行了，这里就不做过多的解释了。</p><p>然后你可执行一下命令来预览你的Blog：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rake generate <span class="comment"># 生成文件</span></span><br><span class="line">rake preview <span class="comment"># 生成本地预览，地址是 http://localhost:400</span></span><br></pre></td></tr></table></figure><p>如果你觉得我没有问题就可以通过下面的命令将博客部署到GitHub上了</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rake deploy <span class="comment"># 会将通过rake generate生成的文件_deploy下的内容push到GitHub的master分支上</span></span><br></pre></td></tr></table></figure><p>记得输入如下命令将所有的改动push到GitHub上</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">'your message'</span></span><br><span class="line">git push origin <span class="built_in">source</span></span><br></pre></td></tr></table></figure><h3 id="撰写blog"><a class="markdownIt-Anchor" href="#撰写blog"></a> 撰写Blog</h3><p>在终端中执行如下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rake new_post[<span class="string">'Post Title'</span>]</span><br></pre></td></tr></table></figure><p>此命令会在source/_post/目录下生成一个类似于2012-01-05-post-title.markdown的文件，用Markdown编辑器编辑这个文件，最上面的<code>---</code>中间的部分是yml格式的一些关于文章的信息，具体含义请参考：<a href="https://github.com/mojombo/jekyll/wiki/yaml-front-matter" target="_blank" rel="noopener">https://github.com/mojombo/jekyll/wiki/yaml-front-matter</a></p><p>编辑好文章之后执行如下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rake generate <span class="comment"># 生成文件</span></span><br><span class="line">rake preview <span class="comment"># 如果你想在本地查看一下的话</span></span><br><span class="line">rake deploy <span class="comment"># 部署到GitHub上</span></span><br></pre></td></tr></table></figure><p>然后你应该就可以在<code>http://&lt;username&gt;.github.com</code>上看到你写的文章了，更多命令请参考<a href="http://octopress.org/docs/blogging/" target="_blank" rel="noopener">http://octopress.org/docs/blogging/</a></p><h3 id="绑定自己的域名"><a class="markdownIt-Anchor" href="#绑定自己的域名"></a> 绑定自己的域名</h3><p>如果你想绑定自己的域名也是可以的，方法也很简单~。首先要参考GitHub上的帮助文章<a href="https://help.github.com/articles/setting-up-a-custom-domain-with-pages" target="_blank" rel="noopener">https://help.github.com/articles/setting-up-a-custom-domain-with-pages</a>来设置自己域名的DNS。然后执行下面的命令（<a href="http://octopress.org/docs/deploying/github/#custom_domains" target="_blank" rel="noopener">参考</a>）：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">'yourdomain.com'</span> &gt; <span class="built_in">source</span>/CNAME</span><br></pre></td></tr></table></figure><p>接下来就是等待域名解析生效了~</p><h3 id="一些小提示"><a class="markdownIt-Anchor" href="#一些小提示"></a> 一些小提示</h3><p>记得每次写完文章之后用如下命令将写的文章同步到GitHub上：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add -A</span><br><span class="line">git commit <span class="string">'your message'</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>这样你的文章就不会丢失了<sub>，哪怕是重装电脑</sub>，下次只需要把GitHub仓库clone下来然后重做上面的某些步骤就可以了!不过你也可以将文件保存到<a href="http://db.tt/062Uch29" target="_blank" rel="noopener">Dropbox</a>上，也是很方便的。</p><p>更多信息和更高级的内容请参考Octopress的<a href="http://octopress.org/docs/" target="_blank" rel="noopener">官方文档</a>和Jekyll的<a href="https://github.com/mojombo/jekyll/wiki" target="_blank" rel="noopener">Wiki</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;现在通过&lt;a href=&quot;https://github.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;+&lt;a href=&quot;http://octopress.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Octopress&lt;/a&gt;来搭建个人博客的越来越多了。这几天我也试着通过这个试着搭建一下，开始觉得很折腾，后来折腾出来之后发现还是买简单的。&lt;/p&gt;
&lt;p&gt;通过&lt;a href=&quot;https://github.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;+&lt;a href=&quot;http://octopress.org/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Octopress&lt;/a&gt;搭建的博客有几个很显而易见的有点：&lt;/p&gt;
    
    </summary>
    
      <category term="Other" scheme="http://firestudio.cn/categories/other/"/>
    
    
      <category term="Octopress" scheme="http://firestudio.cn/tags/octopress/"/>
    
      <category term="GitHub" scheme="http://firestudio.cn/tags/github/"/>
    
  </entry>
  
</feed>
